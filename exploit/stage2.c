#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include "funcs.h"

#define THUMB_BX_LR                 (0x4770)
#define THUMB_MOV_R0_1              (0x2001)
#define THUMB_MOV_R0_0_STR_R0_R3    (0x60182000)

#define WRITE32(_addr, _val) \
    *(volatile uint32_t *)(_addr) = _val

#define WRITE16(_addr, _val) \
    *(volatile uint16_t *)(_addr) = _val

static
size_t _strlen(const char *str) {
    size_t len = 0;

    for (; *str; str++) {
        len++;
    }

    return len;
}

static
void heap_reinit() {
    printf("reinitializing heap\n");

    /* clear out heap metadata */
    memset((void *)HEAP_METADATA, 0, 0xA8);

    /* add main chunk (32 MiB usually) */
    heap_add_chunk((void *)HEAP_BASE, HEAP_LEN);
}

__attribute__((naked))
void UpdateDeviceTree_tramp() {
    asm("ldr r0, 1f");
    asm("bx  r0");
    asm("1:");
    asm(".long _UpdateDeviceTree__hook");
}

static
void patches_apply() {
    /* neuter free() to avoid messing up heap metadata */
    WRITE16(FREE_ADDR, THUMB_BX_LR);

    /* patch Image3 signature checks */
    WRITE32(IMAGE3_PATCH, THUMB_MOV_R0_0_STR_R0_R3);

    /* debug-enabled patch */
    WRITE16(DEBUG_ENABLED_PATCH_ADDR1, THUMB_MOV_R0_1);
    WRITE16(DEBUG_ENABLED_PATCH_ADDR2, THUMB_MOV_R0_1);

    /* point boot args string to a new location */
    WRITE32(BOOT_ARGS_PATCH_ADDR1, BOOT_ARGS_NEW_ADDR);
    WRITE32(BOOT_ARGS_PATCH_ADDR2, BOOT_ARGS_NEW_ADDR);

    /* populate them from the env var */
    const char *boot_args = env_get("boot-args");
    if (!boot_args) {
        boot_args = "";
    }

    size_t boot_args_len = _strlen(boot_args);
    memcpy((void *)BOOT_ARGS_NEW_ADDR, boot_args, boot_args_len + 1);

    /* add "amfi=0xff" boot-arg if not already there */
    const char *amfi_arg = " amfi=0xff";
    if (boot_args_len == 0) {
        /* get rid of the space if boot-args string is empty */
        amfi_arg++;
    }

    if (!contains_boot_arg((const char *)BOOT_ARGS_NEW_ADDR, "amfi=", true)) {
        strlcat((char *)BOOT_ARGS_NEW_ADDR, amfi_arg, 512);
    }

    /* apply UpdateDeviceTree hook */
    void *tramp = (void *)((uintptr_t)UpdateDeviceTree_tramp & ~1); // clear the Thumb bit
    memcpy((void *)UPDATE_DEVICE_TREE_TRAMP, tramp, 8 /* plz no ldr.w */);
    WRITE32(UPDATE_DEVICE_TREE_HOOK_ADDR, UPDATE_DEVICE_TREE_HOOK_PATCH);

    /* clear caches to make the changes effective */
    arm_clean_caches();
}

int UpdateDeviceTree__hook() {
    UpdateDeviceTree();

    void *chosen = NULL;
    if (!FindNode(0, "chosen", &chosen)) {
        printf("%s: failed to find the /chosen node\n", __func__);
        return -1;
    }

    /* populate nvram-proxy-data as iOS 5 iBoot doesn't do it */
    char *propName = "nvram-proxy-data";
    uint32_t propSize = 0;
    void *propData = NULL;

    if (!FindProperty(chosen, &propName, &propData, &propSize)) {
        printf("%s: failed to find the \"%s\" node\n", __func__, propName);
        return -1;
    }

    if (propSize != NVRAM_DATA_LEN) {
        printf("%s: \"%s\" prop has unexpected length (0x%x)\n", __func__, propName, propSize);
        return -1;
    }

    if (!nand_nvram_read(0, (void *)NVRAM_DATA_BASE, NVRAM_DATA_LEN)) {
        return -1;
    }

    memcpy(propData, (void *)NVRAM_DATA_BASE, NVRAM_DATA_LEN);

    printf("%s: populated \"%s\"\n", __func__, propName);

    /* same for random-seed */
    propName = "random-seed";
    propSize = 0;
    propData = NULL;

    if (!FindProperty(chosen, &propName, &propData, &propSize)) {
        printf("%s: failed to find the \"%s\" node\n", __func__, propName);
        return -1;
    }

    random_get_bytes(propData, propSize);

    printf("%s: populated \"%s\"\n", __func__, propName);

    return 0;
}

#define BOOT_DEVICE "nand0a"
#define MOUNT_POINT "/boot"
#define KERNEL_PATH "/System/Library/Caches/com.apple.kernelcaches/kernelcache"

static
int boot() {
    printf("mounting root filesystem\n");
    if (fs_mount(BOOT_DEVICE, "hfs", MOUNT_POINT) != 0) {
        printf("failed to mount?!\n");
        return -1;
    }

    void *addr = NULL;
    if (load_kernelcache_file(MOUNT_POINT KERNEL_PATH, &addr) != 0) {
        printf("failed to load kernelcache?!\n");
        return -1;
    }

    printf("booting Darwin...\n");
    return boot_darwin(addr, *(void **)BOOT_ARGS_STRUCT);
}

void start() {
    printf("============== stage2 start ==============\n");

    heap_reinit();

    patches_apply();

    boot();

    printf("boot failed, rebooting into recovery mode!\n");
    env_set("auto-boot", "false", 1 /* persistent */);

    nvram_save();

    platform_reset(0);
}
